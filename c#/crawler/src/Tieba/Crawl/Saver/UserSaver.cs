using Microsoft.EntityFrameworkCore.ChangeTracking;

namespace tbm.Crawler.Tieba.Crawl.Saver;

public partial class UserSaver
{
    protected override bool FieldUpdateIgnorance
        (string propName, object? oldValue, object? newValue) => propName switch
    { // possible randomly respond with null
        nameof(User.IpGeolocation) when newValue is null => true,
        // possible clock drift across multiple response from tieba api
        // they should sync their servers with NTP
        /* following sql can track these drift
        SELECT portraitUpdatedAtDiff, COUNT(*), MAX(uid), MIN(uid), MAX(portraitUpdatedAt), MIN(portraitUpdatedAt)
        FROM (
            SELECT uid, portraitUpdatedAt, CAST(portraitUpdatedAt AS SIGNED)
                    - LEAD(CAST(portraitUpdatedAt AS SIGNED)) OVER (PARTITION BY uid ORDER BY time DESC) AS portraitUpdatedAtDiff
                FROM tbmcr_user WHERE portraitUpdatedAt IS NOT NULL
        ) AS T
        WHERE portraitUpdatedAtDiff > -100 AND portraitUpdatedAtDiff < 100
        GROUP BY portraitUpdatedAtDiff ORDER BY portraitUpdatedAtDiff;
        */
        nameof(User.PortraitUpdatedAt)
            when Math.Abs((newValue as int? ?? 0) - (oldValue as int? ?? 0)) <= 10 =>
            true,
        _ => false
    };

    protected override bool FieldRevisionIgnorance
        (string propName, object? oldValue, object? newValue) => propName switch
    { // ignore revision that figures update existing old users that don't have ip geolocation
        nameof(User.IpGeolocation) when oldValue is null => true,
        _ => false
    };

    protected override bool ShouldIgnoreEntityRevision(string propName, PropertyEntry propEntry, EntityEntry entityEntry)
    {
        // ThreadCrawlFacade.ParseLatestRepliers() will save users with empty string as portrait
        // they may soon be updated by (sub) reply crawler after it find out the latest reply
        // so we should ignore its revision update for all fields
        // ignore entire record is not possible via IFieldChangeIgnorance.GlobalFieldChangeIgnorance.Revision()
        // since it can only determine one field at the time
        if (propName != nameof(User.Portrait) || propEntry.OriginalValue is not "") return false;

        // invokes OriginalValues.ToObject() to get a new instance
        // since entityInTracking is reference to the changed one
        var user = (User)entityEntry.OriginalValues.ToObject();

        // create another user instance with only fields of latest replier filled
        var latestReplier = User.CreateLatestReplier(user.Uid, user.Name, user.DisplayName);

        // if they are same by fields values, the original one is the latest replier
        // that previously generated by ParseLatestRepliers()
        return User.EqualityComparer.Instance.Equals(user, latestReplier);
    }

    protected override Dictionary<Type, AddRevisionDelegate>
        AddRevisionDelegatesKeyBySplitEntityType { get; } = new()
    {
        {
            typeof(UserRevision.SplitDisplayName), (db, revisions) =>
                db.Set<UserRevision.SplitDisplayName>()
                    .AddRange(revisions.OfType<UserRevision.SplitDisplayName>())
        },
        {
            typeof(UserRevision.SplitPortraitUpdatedAt), (db, revisions) =>
                db.Set<UserRevision.SplitPortraitUpdatedAt>()
                    .AddRange(revisions.OfType<UserRevision.SplitPortraitUpdatedAt>())
        },
        {
            typeof(UserRevision.SplitIpGeolocation), (db, revisions) =>
                db.Set<UserRevision.SplitIpGeolocation>()
                    .AddRange(revisions.OfType<UserRevision.SplitIpGeolocation>())
        }
    };

    [SuppressMessage("StyleCop.CSharp.SpacingRules", "SA1025:Code should not contain multiple whitespace in a row")]
    protected override NullFieldsBitMask GetRevisionNullFieldBitMask(string fieldName) => fieldName switch
    {
        nameof(User.Name)   => 1,
        nameof(User.Gender) => 1 << 3,
        nameof(User.Icon)   => 1 << 5,
        _ => 0
    };
}
public partial class UserSaver(
    ILogger<UserSaver> logger, SaverLocks<Uid> locks,
    IDictionary<Uid, User> users)
    : SaverWithRevision<BaseUserRevision>(logger)
{
    public delegate UserSaver New(IDictionary<Uid, User> users);

    public void Save(CrawlerDbContext db, PostType postType)
    {
        if (users.Count == 0) return;
        locks.AcquireLocksThen(newlyLocked =>
            {
                var existingUsersKeyByUid = (from user in db.Users.AsTracking()
                    where newlyLocked.Select(u => u.Uid).Contains(user.Uid)
                    select user).ToDictionary(u => u.Uid);
                SaveEntitiesWithRevision(db,
                    u => new UserRevision
                    {
                        TakenAt = u.UpdatedAt ?? u.CreatedAt,
                        Uid = u.Uid,
                        TriggeredBy = postType
                    },
                    newlyLocked.ToLookup(u => existingUsersKeyByUid.ContainsKey(u.Uid)),
                    u => existingUsersKeyByUid[u.Uid]);
            },
            alreadyLocked => users
                .ExceptBy(alreadyLocked, pair => pair.Key).Select(pair => pair.Value).ToList(),
            newlyLocked => newlyLocked.Select(u => u.Uid));
    }

    public IEnumerable<Uid> AcquireUidLocksForSave(IEnumerable<Uid> usersId)
    {
        var exceptLocked = new List<Uid>();
        locks.AcquireLocksThen(
            newlyLocked => exceptLocked.AddRange(newlyLocked),
            alreadyLocked => usersId.Except(alreadyLocked).ToList(),
            i => i);
        return exceptLocked;
    }

    public void OnPostSave() => locks.ReleaseLocalLocked();
}
